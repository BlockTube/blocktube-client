<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/ipfs-upload/ipfs-upload.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">



<dom-module id="stube-record">
  <template>

  <script src="./../bower_components/whammy/whammy.js"></script>

<!--   <link href="../../bower_components/video.js/dist/video-js.css" rel="stylesheet">
  <link href="../../bower_components/videojs-record/src/css/videojs.record.css" rel="stylesheet">


  <script src="./../bower_components/video.js/dist/video.min.js"></script>


  <script src="../../bower_components/videojs-record/src/js/videojs.record.js"></script>
 -->
    <!-- This is temporary  -->
    <iron-localstorage name="blocktube-clips"
    value="{{clips}}"
    on-iron-localstorage-load-empty="initclips"
  ></iron-localstorage>

    <style>
      :host {
        display: block;
      }
    </style>


    <video id="myVideo" autoplay="true"></video>
    <paper-icon-button icon="add" on-tap="initrecorder" hidden="{{recorderinit}}"></paper-icon-button>
    <paper-icon-button icon="av:fiber-manual-record" on-tap="record" hidden="{{!recorderinit}}"></paper-icon-button>
    <paper-icon-button icon="av:stop" on-tap="stoprecord" hidden="{{!recorderinit}}"></paper-icon-button>

    <ipfs-upload hidefileinput id="ipfsupload" hash="{{cliphash}}" on-ipfs-hash-received="_setipfshash" on-upload-started="_uploadstart" on-upload-error="_uploaderror" host="/ip4/109.123.70.141/tcp/5001"></ipfs-upload>
    <template is="dom-if" if="{{ipfs_uploading}}">
      <span>Uploading</span>
    </template>
    <template is="dom-if" if="{{cliphash}}">
      <span>Upload complete</span>
    </template>

    <paper-input label="Title" bind-value="{{title}}"></paper-input>
    <paper-input label="Description" bind-value="{{description}}"></paper-input>
    <paper-button raised on-tap="upload">upload</paper-button>
  </template>
  <script src="../../scripts/whammy.min.js"></script>

  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'stube-record',

      properties: {
        web3: {
          type: Object,
          observer: '_web3'
        },
        cliphash: {
          type: String,
          //observer: '_oncliphashreceived'
        },
        readyforupload: {
          type: Boolean,
          value: false
        },
        ipfs_uploading: {
          type: Boolean,
          value: false
        },
        metadata: {
          type: Object,
          value: {},
        }
      },

      ready: function() {
        this.recorderinit = false;
      },

      attached: function(){
       
      },

      initrecorder: function() {
        var self = this;
        if (!window.URL) {
          window.URL = window.URL || window.webkitURL || window.msURL || window.oURL;
        }
        if (!navigator.getUserMedia) {
          navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
        }

        this.requestAnimationFrame = window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame ||
            window.msRequestAnimationFrame || window.oRequestAnimationFrame;

        this.cancelAnimationFrame = window.cancelAnimationFrame ||
            window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame ||
            window.msCancelAnimationFrame || window.oCancelAnimationFrame;


        var self = this;
        navigator.getUserMedia({
            //audio: self.audio,
            video: true
          },
          function(stream) {
            self.$.myVideo.src = window.URL.createObjectURL(stream);
            setTimeout(function() {
              self.$.myVideo.width = 320; //video.clientWidth;
              self.$.myVideo.height = 240; // video.clientHeight;
              // Canvas is 1/2 for performance. Otherwise, getImageData() readback is
              // awful 100ms+ as 640x480.
              self.canvas.width = self.$.myVideo.width;
              self.canvas.height = self.$.myVideo.height;
            }, 1000);

            self.recorderinit = true;
          },
          function(err) {
            throw Error(err);
          });
        this.canvas = document.createElement('canvas');
      },

      record: function() {
        var self = this;

        //this.elapsedTime = $('#elasped-time');
        var ctx = this.canvas.getContext('2d');
        var CANVAS_HEIGHT = this.canvas.height;
        var CANVAS_WIDTH = this.canvas.width;

        this.frames = []; // clear existing frames;
        this.startTime = Date.now();

//        toggleActivateRecordButton();
//        $('#stop-me').disabled = false;

        function drawVideoFrame_(time) {
          self.rafId = window.requestAnimationFrame(drawVideoFrame_);

          ctx.drawImage(self.$.myVideo, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

          document.title = 'Recording...' + Math.round((Date.now() - self.startTime) / 1000) + 's';

          // Read back canvas as webp.
          //console.time('canvas.dataURL() took');
          var url = self.canvas.toDataURL('image/webp', 1); // image/jpeg is way faster :(
          //console.timeEnd('canvas.dataURL() took');
          self.frames.push(url);

          // UInt8ClampedArray (for Worker).
          //frames.push(ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT).data);

          // ImageData
          //frames.push(ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT));
        };

        this.rafId = window.requestAnimationFrame(drawVideoFrame_);
      },

      stoprecord: function() {
        window.cancelAnimationFrame(this.rafId);
        this.endTime = Date.now();
        //$('#stop-me').disabled = true;
        //document.title = ORIGINAL_DOC_TITLE;

        //toggleActivateRecordButton();

        console.log('frames captured: ' + this.frames.length + ' => ' +
          ((this.endTime - this.startTime) / 1000) + 's video');

        // if (!url) {
        var webmBlob = Whammy.fromImageArray(this.frames, 1000 / 60);

        this.$.ipfsupload.add(webmBlob, function(err, res) {

          if (!err && res[0] && res[0].Hash) {
            console.log('hash=', res[0].Hash);
            //              self._createNewUploadContract(res[0].Hash,function(err,contractaddress){
            //                console.log('mined!');
            //                self.push('clips',contractaddress);
            //              });
          } else {
            console.log('error uploading metadata to IPFS', err);
          }
        });



        //    this.url = window.URL.createObjectURL(webmBlob);

        //console.log('download video:',this.url);

        //  }

        //  video.src = url;
        //  downloadLink.href = url;

      },

      // this will be removed later. Temp fix to get a list of uploads
      initclips: function(){
          this.clips = [];
      },

      _uploadstart: function() {
        console.log('upload start');
        this.ipfs_uploading = true;
      },

      _uploaderror: function() {
        console.log('error uploading');
        this.ipfs_uploading = false;
      },

      _setipfshash: function(data) {
        console.log('got hash', this.cliphash);
        this.metadata.uploaddate = Math.floor(new Date().getTime() / 1000);
        this.metadata.video = data.detail.hash;
        this.metadata.filename = data.detail.file.name;
        this.metadata.filesize = data.detail.file.size;
        this.metadata.filemimetype = data.detail.file.type;

        this.ipfs_uploading = false;
        this.createclip();
      },

      upload: function() {
        this.readyforupload = true;
        this.createclip();
      },
      createclip: function() {
        var self = this
        if (this.readyforupload && this.cliphash) {
          // All is ready
          this.metadata.name = this.title;
          this.metadata.description = this.description;

          console.log('ok', this.metadata);
          this.$.ipfsupload.add(JSON.stringify(this.metadata), function(err, res) {
            // Yeah man - create that contract here now please....

            if (!err && res[0] && res[0].Hash) {
              self._createNewUploadContract(res[0].Hash,function(err,contractaddress){
                console.log('mined!');
                self.push('clips',contractaddress);
              });
            } else {
              console.log('error uploading metadata to IPFS', err);
            }
          });
        }
      },
      fixaddress: function(address) {
        function strStartsWith(str, prefix) {
          return str.indexOf(prefix) === 0;
        }

        if (!strStartsWith(address, '0x')) {
          return ('0x' + address);
        }
        return address;
      },

      _createNewUploadContract: function(hash,fn) {
        var self = this;
        this.contracturl = this.resolveUrl('../../contracts/upload.json');
        this.importHref(this.contracturl, function(e) {
          self.contractjson = JSON.parse(e.target.import.body.innerText);

          console.log('Creating new contract on account ', self.account);

          this.web3.eth.getGasPrice(function(err, result) {
            var gasPrice = result.toNumber(10);

            var MyContract = self.web3.eth.contract(self.contractjson.abi);
            //var contractInstance = 
            MyContract.new(hash, 100, 50, {
              from: self.fixaddress(self.account),
              gasPrice: gasPrice,
              gasLimit: 3000000,
              gas: 2000000,
              data: self.contractjson.bytecode
            }, function(err, myContract) {
              if (!err) {
                // NOTE: The callback will fire twice!
                // Once the contract has the transactionHash property set and once its deployed on an address.

                // e.g. check tx hash on the first call (transaction send)
                if (!myContract.address) {
                  console.log('Your upload contract has been deployed to the Ethereum network. Transaction hash is', myContract.transactionHash);
                  self.txhash = myContract.transactionHash;
                  console.log('Wait a new moments while we mine it. You will receive your address when it is mined.');
                  //self.showtoast("Here's the TX hash: " + self.txhash);
                  self.fire('add-toast', {
                    msg: 'Here\'s the TX hash: ' + self.txhash
                  });

                  // check address on the second call (contract deployed)
                } else {
                  console.log('Your upload contract has been deployed. Your contract address is', myContract.address);
                  self.contractaddress = myContract.address;
                  //self.showtoast("Contract deployed: " + self.contractaddress);
                  self.fire('add-toast', {
                    msg: 'Contract deployed: ' + self.contractaddress
                  });
                  fn(err,self.contractaddress);
                }
              } else {
                console.log('error:', err);
                //self.showtoast("Error: " + err);
                self.fire('add-toast', {
                  msg: 'Error.'
                });
                fn(err);
              }
            });
          });

        }, function(e) {
          console.log('ERROR!', e);
        });

      },

    });
  })();



function stop() {
  cancelAnimationFrame(rafId);
  endTime = Date.now();
  $('#stop-me').disabled = true;
  document.title = ORIGINAL_DOC_TITLE;

  toggleActivateRecordButton();

  console.log('frames captured: ' + frames.length + ' => ' +
    ((endTime - startTime) / 1000) + 's video');

  embedVideoPreview();
};

function embedVideoPreview(opt_url) {
  var url = opt_url || null;
  var video = $('#video-preview video') || null;
  var downloadLink = $('#video-preview a[download]') || null;

  if (!video) {
    video = document.createElement('video');
    video.autoplay = true;
    video.controls = true;
    video.loop = true;
    //video.style.position = 'absolute';
    //video.style.top = '70px';
    //video.style.left = '10px';
    video.style.width = canvas.width + 'px';
    video.style.height = canvas.height + 'px';
    $('#video-preview').appendChild(video);

    downloadLink = document.createElement('a');
    downloadLink.download = 'capture.webm';
    downloadLink.textContent = '[ download video ]';
    downloadLink.title = 'Download your .webm video';
    var p = document.createElement('p');
    p.appendChild(downloadLink);

    $('#video-preview').appendChild(p);

  } else {
    window.URL.revokeObjectURL(video.src);
  }

  // https://github.com/antimatter15/whammy
  // var encoder = new Whammy.Video(1000/60);
  // frames.forEach(function(dataURL, i) {
  //   encoder.add(dataURL);
  // });
  // var webmBlob = encoder.compile();

  if (!url) {
    var webmBlob = Whammy.fromImageArray(frames, 1000 / 60);
    url = window.URL.createObjectURL(webmBlob);
  }

  video.src = url;
  downloadLink.href = url;
};

  </script>
</dom-module>
